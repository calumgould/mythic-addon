{
  "_id": "bc74d39d-7795-43c1-b5a4-ab03085aee7f",
  "name": "Damage Calculator",
  "type": "script",
  "scope": "global",
  "command": "const parser = new DOMParser();\n\nconst TRAITS_ADD_PIERCE_AGAINST_SHIELDS = ['Penetrating', 'Spread', 'Cauterize', 'Kinetic', 'Blast and Kill Radius', 'Carpet']\n\nconst hitLocationMap = {\n    'Head': 'head',\n    'Right Arm': 'rightArm',\n    'Right Leg': 'rightLeg',\n    'Chest': 'chest',\n    'Left Arm': 'leftArm',\n    'Left Leg': 'leftLeg'\n}\n\nconst getSelectedToken = () => canvas.tokens.controlled[0]\n\nconst getCharacter = () => {\n    const user = game.user\n\n    // If there's an active selected token then use that as the character, if not use the user's character\n    const selectedToken = getSelectedToken()\n\n    if (selectedToken) {\n        const tokenActorId = selectedToken.document.actorId\n        const selectedCharacter = game.actors.find((actor) => actor._id === tokenActorId)\n\n        return selectedCharacter\n    }\n\n    if (!user.character) {\n        console.error('No character found for user')\n    }\n\n    return user.character\n}\n\nconst isNamedCharacter = (character) => character.type === 'Named Character'\n\nconst getLastAttackFromChat = () => {\n    // Find last attack in chat messages\n    const chatMessages = game.messages.contents.reverse()\n    const lastAttackMessage = chatMessages.find((msg) => msg.flavor.includes('Attack'))\n\n    return lastAttackMessage\n}\n\nconst extractDataForHits = (htmlString) => {\n    const parsedHtml = parser.parseFromString(htmlString, 'text/html');\n\n    const hits = Array.from(parsedHtml.querySelectorAll('.post-attack div'))\n    .filter(attacks => attacks.querySelector('.damage-block'))\n    .map(hit => {\n        const hitOutcome = hit.querySelector('.outcome')\n\n        // the hitNumber is the first p tag in the outcome div\n        const hitTag = hitOutcome.querySelector('p')\n        const hitNumber = hitTag.textContent.trim() || '?'\n\n        const damageBlock = hit.querySelector('.damage-block')\n\n        const additions = damageBlock.querySelector('.damage-block p').textContent.trim();\n\n        const pierceMatch = additions.match(/Pierce\\s(\\d+)/);\n        const pierce = pierceMatch ? pierceMatch[1] : null;\n\n        const locationMatch = additions.match(/:\\s([a-zA-Z\\s-]+)\\s-/);\n        const location = locationMatch ? locationMatch[1].trim() : null;\n\n        const rollResults = damageBlock.querySelectorAll('.inline-roll.inline-result')\n\n        const damageInstances = Array.from(rollResults).map((result) => {\n            const damage = result.textContent.trim();\n\n            return {\n                damage: parseInt(damage, 10),\n                pierce: parseInt(pierce, 10),\n                location,\n            }\n        })\n\n        return {\n            hitNumber: parseInt(hitNumber, 10),\n            damageInstances\n        }\n    });\n\n    return hits\n}\n\nconst handleWeaponSpecialRules = (weaponSpecialRules) => {\n    // If the weapon has certain special rules, when damaging shields it adds the weapon's pierce to the damage\n    const weaponAddsPierceAgainstShields = weaponSpecialRules.some(trait => TRAITS_ADD_PIERCE_AGAINST_SHIELDS.includes(trait))\n    const weaponHasHeadshotSpecialRule = weaponSpecialRules.includes('Headshot')\n\n    return {\n        weaponAddsPierceAgainstShields,\n        weaponHasHeadshotSpecialRule\n    }\n}\n\nconst calculateDamage = ({ damage, pierce, location, resistance, weaponTraits, coverLocations, coverPoints, shields }) => {\n    const mappedHitLocation = hitLocationMap[location]\n    const applyHeadshot = location === 'Head' && weaponTraits.weaponHasHeadshotSpecialRule\n    const isHitLocationInCover = coverLocations[mappedHitLocation]\n\n    // When a weapon has the headshot special rule, it ignores the toughness modifier when calculating resistance\n    let resistanceAtHitLocation = applyHeadshot ? resistance[mappedHitLocation].protection : resistance[mappedHitLocation].resistance\n\n    // If location being hit is in cover, add the cover points to the overall resistance\n    if (isHitLocationInCover) {\n        resistanceAtHitLocation += coverPoints\n    }\n\n    // If the target has shields then the damage should be applied to the shields first\n    if (shields > 0) {\n        const { shieldDamage, armourDamage } = calculateShieldDamage({ damage, pierce, weaponTraits, shields })\n\n        // If no damage got through to the target's armour, we don't need to do anything else\n        if (armourDamage <= 0) {\n            return { shieldDamage, woundDamage: 0 }\n        }\n\n        // If the shield is depleted, the remaining damage goes through to the target's armour, the normal resistances apply but pierce does not apply since it was already applied to the shield damage\n        const damageThroughResistance = (resistanceAtHitLocation > armourDamage)\n            ? 0\n            : armourDamage - resistanceAtHitLocation\n\n        return { shieldDamage, woundDamage: damageThroughResistance }\n    }\n\n    // If the pierce is greater than the damage resistance, it shouldn't add any damage. Instead it pierces through the target to whatever is behind and should be handled separately.\n    const effectiveResistance = pierce > resistanceAtHitLocation\n        ? 0\n        : (resistanceAtHitLocation - pierce)\n\n    const damageThroughResistance = damage - effectiveResistance\n\n    return { shieldDamage: 0, woundDamage: damageThroughResistance }\n}\n\nconst calculateShieldDamage = ({ damage, pierce, weaponTraits, shields }) => {\n    const damageToShields = weaponTraits.weaponAddsPierceAgainstShields\n        ? damage + pierce\n        : damage\n\n    // If the shield health is greater than the damage, then the shields absorb all the damage and we don't need to do anything else\n    if (shields > damageToShields) {\n        return { shieldDamage: damageToShields, armourDamage: 0 }\n    }\n\n    // If shields would be depleted, the remaining damage goes through to the target's armour\n    let damageThroughToArmour = damageToShields - shields\n\n    // If pierce was added to the damage against shields, it no longer applies when damage spills through to the target's armour\n    // Pierce is also applied first to the shields, before any of the base damage\n    if (weaponTraits.weaponAddsPierceAgainstShields) {\n        const remainingPierce = pierce - shields\n\n        if (remainingPierce > 0) {\n            damageThroughToArmour -= remainingPierce\n        }\n    }\n\n    return { shieldDamage: shields, armourDamage: damageThroughToArmour }\n}\n\nconst generateChatMessage = ({ characterName, remainingShields, remainingWounds, totalDamage, hasShields }) => {\n    // Target took no damage\n    if (totalDamage <= 0) {\n        if (hasShields) {\n            return `${characterName} took no damage. They still have ${remainingShields} shields and ${remainingWounds} wounds.`\n        } else {\n            return `${characterName} took no damage. They still have ${remainingWounds} wounds.`\n        }\n    }\n\n    // Target has been downed\n    if (remainingWounds <= 0) {\n        if (hasShields) {\n            return `${characterName} is down! They took ${totalDamage} damage. They have ${remainingShields} shields and ${remainingWounds} wounds.`\n        } else {\n            return `${characterName} is down! They took ${totalDamage} damage. They have ${remainingWounds} wounds.`\n        }\n    }\n\n    // Target took some damage\n    if (hasShields) {\n        return `${characterName} took ${totalDamage} damage. They have ${remainingShields} shields and ${remainingWounds} wounds remaining.`\n    } else {\n        return `${characterName} took ${totalDamage} damage. They have ${remainingWounds} wounds remaining.`\n    }\n}\n\nconst applyDamage = ({ remainingWounds, remainingShields }) => {\n    const character = getCharacter()\n\n    if (isNamedCharacter(character)) {\n        character.update({\n            \"system.wounds.value\": remainingWounds,\n            \"system.shields.value\": remainingShields\n        })\n    } else {\n        // If it's a minion, just update the wounds of the token since multiple minions can have the same character sheet\n        const selectedToken = getSelectedToken()\n        selectedToken.actor.update({\n            \"system.wounds.value\": remainingWounds,\n            \"system.shields.value\": remainingShields\n        })\n    }\n}\n\n// Html for the dialog\nconst dialogStyles = `\n<style>\n    .form {\n        margin-bottom: 5px;\n        display: flex;\n        flex-direction: column;\n        gap: 5px;\n    }\n    .form-section {\n        display: flex;\n        flex-wrap: nowrap;\n        align-items: center;\n        gap: 10px;\n    }\n    .checkbox-group {\n        display: flex;\n        flex-wrap: wrap;\n        gap: 10px;\n    }\n    .checkbox-label {\n        display: flex;\n        align-items: center;\n        gap: 5px;\n    }\n    .checkbox-label input[type=\"checkbox\"] {\n        margin: 0;\n    }\n    .location-checkbox-label {\n        width: calc(33.33% - 10px);\n    }\n    .input-label {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        white-space: nowrap;\n    }\n</style>\n`;\n\nconst hitLocationFormOptions = Object.entries(hitLocationMap).map(([key, value]) => ({ name: value, label: key }))\n\nconst coverLocationOptions = hitLocationFormOptions\n    .map((location) => `\n        <label class=\"location-checkbox-label checkbox-label\">\n            <input type=\"checkbox\" name=\"coverLocation\" value=\"${location.name}\" />\n            ${location.label}\n        </label>\n    `)\n    .join(\"\");\n\nconst coverLocationsSection = `\n        <fieldset class=\"form-section\">\n            <legend>Locations in Cover</legend>\n            <div class=\"checkbox-group\">\n                ${coverLocationOptions}\n            </div>\n        </fieldset>\n`\n\nconst whisperResultSection = `\n<fieldset class=\"form-section\">\n    <legend>Options</legend>\n    <label class=\"checkbox-label\">\n        <input type=\"checkbox\" name=\"whisperResult\" value=\"whisperResult\" />\n        Whisper Result\n    </label>\n</fieldset>\n`\n\nconst resistanceModifiersSection = `\n<fieldset class=\"form-section\">\n    <legend>Resistance Modifiers</legend>\n    <label class='input-label'>\n        Cover Points\n        <input type=\"number\" name=\"coverPoints\" class=\"cover-points-input\" value=\"0\" />\n    </label>\n\n    <label class='input-label'>\n        Extra Pierce\n        <input type=\"number\" name=\"extraPierce\" class=\"extra-pierce-input\" value=\"0\" />\n    </label>\n</fieldset>\n`\n\nconst damageModifiersSection = `\n<fieldset class=\"form-section\">\n    <legend>Damage Modifiers</legend>\n    <label class='input-label'>\n        Damage Multiplier\n        <input type=\"number\" name=\"damageMultiplier\" class=\"damage-multiplier-input\" value=\"1\" />\n    </label>\n</fieldset>\n`\n\nconst hitsSection = `\n<fieldset class=\"form-section\">\n    <legend>Hits</legend>\n    <div class=\"damage-instances-container\">\n        <!-- Dynamically generated checkboxes will render here -->\n    </div>\n</fieldset>\n`\n\nconst formSection = `\n<form class='form'>\n    ${whisperResultSection}\n    ${resistanceModifiersSection}\n    ${damageModifiersSection}\n    ${coverLocationsSection}\n    ${hitsSection}\n</form>\n`\n\nnew Dialog({\n    title: 'Damage Calculator',\n    content: `\n        ${dialogStyles}\n        ${formSection}\n    `,\n    buttons:{\n      confirm: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: \"Calculate\",\n        callback: (html) => {\n            const character = getCharacter()\n\n            if (!character) {\n                console.error('No character selected or found for user.')\n                return\n            }\n\n            const isNamedCharacter = character.type === 'Named Character'\n            const selectedToken = getSelectedToken()\n            const callsign = character.name.match(/\"([^\"]+)\"/)\n            const characterName = callsign ? callsign[1] : character.name\n\n            // If it's a minion, get data from the token since multiple minions can have the same character sheet\n            const resistance = isNamedCharacter ? character.system.armor : selectedToken.actor.system.armor\n            const currentWounds = isNamedCharacter ? character.system.wounds.value : selectedToken.actor.system.wounds.value\n            const hasShields = isNamedCharacter ? !!character.system.shields.max : !!selectedToken.actor.system.shields.max\n            const currentShields = isNamedCharacter ? character.system.shields.value : selectedToken.actor.system.shields.value\n\n            // Parse all the form data inputs\n            // Options\n            const whisperResult = html.find(\"input[name='whisperResult']\").is(':checked')\n            // Resistance modifiers\n            const coverPoints = parseInt(html.find(\"input[name='coverPoints']\").val(), 10);\n            const extraPierce = parseInt(html.find(\"input[name='extraPierce']\").val(), 10);\n\n            // Damage modifiers\n            const damageMultiplier = parseInt(html.find(\"input[name='damageMultiplier']\").val(), 10);\n\n            // Cover Locations\n            const coverLocationInputs = html.find(\"input[name='coverLocation']\")\n\n            // Hits\n            const hits = html.find(\"input[name='hits']\")\n\n            const coverLocations = coverLocationInputs.toArray().reduce((curr, el) => {\n                const location = el.value;\n                curr[location] = el.checked;\n                return curr;\n            }, {});\n\n            const appliedHits = hits.toArray().reduce((curr, el) => {\n                const hit = el.value;\n                curr[hit] = el.checked;\n                return curr;\n            }, {});\n\n            const lastAttackMessage = getLastAttackFromChat()\n\n            // Extract data from the last attack\n            const hitData = extractDataForHits(lastAttackMessage.content)\n            const lastAttackHtml = parser.parseFromString(lastAttackMessage.content, 'text/html');\n\n            // Get weapon traits from weapon used in the attack\n            const weaponSpecialRules = Array.from(lastAttackHtml.querySelectorAll('aside.special .special-rule'))\n                .map(span => span.textContent.trim());\n            const weaponTraits = handleWeaponSpecialRules(weaponSpecialRules)\n\n            const hitResult = hitData.reduce((acc, curr) => {\n                const { hitNumber, damageInstances } = curr\n\n                if (!appliedHits[hitNumber]) {\n                    // if hit wasn't checked we don't calculate damage, this could be because it was evaded for example\n                    return acc\n                }\n\n                // Each hit can have multiple instances of damage, e.g burst fire so we need to loop over all of them\n                const damageResults = damageInstances.reduce((acc, curr) => {\n                    const { damage, pierce, location } = curr\n\n                    // Handle any extra pierce being applied form the form, e.g. from a charge\n                    const totalPierce = pierce + extraPierce\n\n                    // Handle any damage multipliers being applied from the form, e.g. from a grenade's kill radius\n                    const totalDamage = damage * damageMultiplier\n\n                    const { shieldDamage, woundDamage } = calculateDamage({\n                        damage: totalDamage,\n                        pierce: totalPierce,\n                        location,\n                        resistance,\n                        weaponTraits,\n                        coverLocations,\n                        coverPoints,\n                        shields: acc.remainingShields\n                    })\n\n                    acc.totalDamage += shieldDamage\n                    acc.totalDamage += woundDamage\n                    acc.remainingShields -= shieldDamage\n                    acc.remainingWounds -= woundDamage\n\n                    return acc\n                }, { totalDamage: 0, remainingWounds: acc.remainingWounds, remainingShields: acc.remainingShields })\n\n                acc.totalDamage += damageResults.totalDamage\n                acc.remainingWounds = damageResults.remainingWounds\n                acc.remainingShields = damageResults.remainingShields\n\n                return acc\n            }, { totalDamage: 0, remainingWounds: currentWounds, remainingShields: currentShields })\n\n            const { totalDamage, remainingWounds, remainingShields } = hitResult\n\n            const chatMessage = generateChatMessage({ characterName: characterName, remainingShields, remainingWounds, totalDamage, hasShields })\n\n            applyDamage({ remainingWounds, remainingShields })\n\n            ChatMessage.create({\n                user: game.user._id,\n                speaker: ChatMessage.getSpeaker(),\n                content: chatMessage,\n                // If the user wants the result to be private, only they will see the message\n                whisper: whisperResult ? [game.user._id] : null\n            });\n        }\n      },\n      cancel: {\n        label: 'Cancel'\n      }\n    },\n    render: (html) => {\n        const damageInstancesContainer = html.find('.damage-instances-container');\n\n        const lastAttackMessage = getLastAttackFromChat()\n        const hitData = extractDataForHits(lastAttackMessage.content)\n\n        hitData.forEach((hit) => {\n            const { hitNumber, damageInstances } = hit;\n\n            const damageText = damageInstances.map(({ damage }) => damage).join(', ')\n            // Pierce should be the same for all damage instances of a single hit, e.g using burst fire\n            const pierce = damageInstances[0].pierce\n            const hitLocation = damageInstances[0].location\n\n            const label = $(`\n                <label class=\"checkbox-label\">\n                    <input type=\"checkbox\" name=\"hits\" value=\"${hitNumber}\" checked />\n                    Hit ${hitNumber} || ${damageText} Damage | Pierce ${pierce} | ${hitLocation}\n                </label>`\n            );\n\n            damageInstancesContainer.append(label);\n        });\n    }\n  }).render(true);"
}