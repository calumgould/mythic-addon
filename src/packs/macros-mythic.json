[
  {
    "_id": "mythic-damage-calculator",
    "name": "Damage Calculator",
    "type": "script",
    "scope": "global",
    "img": "modules/mythic-addon/assets/calculator.svg",
    "command": "const parser = new DOMParser()\n\nconst hitLocationMap = {\n  Head: 'head',\n  'Right Arm': 'rightArm',\n  'Right Leg': 'rightLeg',\n  Chest: 'chest',\n  'Left Arm': 'leftArm',\n  'Left Leg': 'leftLeg',\n}\n\nconst vehicleBreakpointMap = {\n  Engine: 'eng',\n  Hull: 'hull',\n  Mobility: 'mob',\n  Optics: 'op',\n  Weapon: 'wep',\n}\n\nconst reversedVehicleBreakpointMap = Object.fromEntries(Object.entries(vehicleBreakpointMap).map(([key, value]) => [value, key]))\n\n// Should be a string format like '1d10' or '1d6 + 2', etc.\nconst rollDice = (dice) => {\n  const roll = new Roll(dice).evaluate({ async: false })\n  return roll.total\n}\n\nconst calculateHitLocation = (hitRoll) => {\n  if (hitRoll >= 1 && hitRoll <= 10) return 'Head'\n  if (hitRoll >= 11 && hitRoll <= 20) return 'Left Arm'\n  if (hitRoll >= 21 && hitRoll <= 30) return 'Right arm'\n  if (hitRoll >= 31 && hitRoll <= 45) return 'Left Leg'\n  if (hitRoll >= 46 && hitRoll <= 60) return 'Right Leg'\n  if (hitRoll >= 61 && hitRoll <= 100) return 'Chest'\n}\n\nconst getSelectedToken = () => {\n  const selectedTokens = canvas.tokens.controlled\n\n  if (selectedTokens.length > 1) {\n    console.warn('More than one token selected, the first one selected will be used. If you get unexpected results please only select one token.')\n  }\n\n  return selectedTokens[0]\n}\n\nconst getTarget = () => {\n  const selectedToken = getSelectedToken()\n\n  // If user selected a token, use that token's data\n  if (selectedToken) {\n    return { token: selectedToken, actor: selectedToken.actor }\n  }\n\n  // If no token is selected, try and fallback to the user's character\n  if (!game.user.character) {\n    ui.notifications.error('No target found. Please select a token.')\n    return { actor: null, token: null }\n  }\n\n  const actor = game.user.character\n\n  const tokens = actor.getActiveTokens()\n\n  if (tokens.length > 1) {\n    console.warn('More than one active token found for character, the first one will be used. If you get unexpected results please select a specific token instead.')\n  }\n\n  return { actor, token: tokens[0] }\n}\n\nconst getLastAttackFromChat = () => {\n  // Find last attack in chat messages\n  const chatMessages = game.messages.contents.reverse()\n  const lastAttackMessage = chatMessages.find((msg) => msg.flavor.includes('Attack'))\n\n  return lastAttackMessage\n}\n\n// This function extracts the data from the html string of the last attack message, then loops over each hit and extracts the damage instances, with damage, pierce and hit location\nconst extractDataForHits = (htmlString) => {\n  const parsedHtml = parser.parseFromString(htmlString, 'text/html')\n\n  const hits = Array.from(parsedHtml.querySelectorAll('.post-attack div'))\n    .filter((attacks) => attacks.querySelector('.damage-block'))\n    .map((hit) => {\n      // hitOutcome is a div that contains the number number\n      const hitOutcome = hit.querySelector('.outcome')\n\n      const hitTags = hitOutcome.querySelectorAll('p')\n      // the hitNumber is the first p tag in the outcome div\n      const hitNumber = hitTags[0].textContent.trim() || '?'\n      // the hitNumber is the third p tag in the outcome div\n      const hitRollMatch = hitTags[2].textContent.trim().match(/^\\d{1,3}/)\n      const hitRoll = hitRollMatch ? hitRollMatch[0] : 0\n\n      // damageBlock is a div that contains the damage instances, pierce and location\n      const damageBlock = hit.querySelector('.damage-block')\n\n      const additions = damageBlock.querySelector('.damage-block p').textContent.trim()\n\n      // Look through the element for pierce\n      const pierceMatch = additions.match(/Pierce\\s(\\d+)/)\n      const pierce = pierceMatch ? pierceMatch[1] : null\n\n      // Look through the element for location\n      const locationMatch = additions.match(/:\\s*([\\p{L}\\s-]+?)(?=\\s*-|\\n|$)/u)\n      const location = locationMatch ? locationMatch[1].trim() : null\n\n      const sublocationMatch = additions.match(/- ([^\\n\\r]+)$/)\n      const sublocation = sublocationMatch ? sublocationMatch[1].trim() : null\n\n      const rollResults = damageBlock.querySelectorAll('.inline-roll.inline-result')\n\n      // Loop over each damage instance and extract the damage\n      // If there are multiple damage instances, e.g. burst fire, the pierce and hit location are the same so we can just use the above values\n      const damageInstances = Array.from(rollResults).map((result) => {\n        const damage = result.textContent.trim()\n\n        return {\n          damage: parseInt(damage, 10),\n          pierce: parseInt(pierce, 10),\n          location,\n        }\n      })\n\n      return {\n        hitNumber: parseInt(hitNumber, 10),\n        hitRoll: parseInt(hitRoll, 10),\n        damageInstances,\n      }\n    })\n\n  return hits\n}\n\nconst getWeaponSpecialRules = (html) => {\n  const weaponSpecialRules = Array.from(html.querySelectorAll('aside.special .special-rule')).map((span) => span.textContent.trim().replace(/\\s*\\(\\d+\\)/, ''))\n\n  // If the weapon has any of these special rules, when damaging energy shields it adds the weapon's pierce to the damage\n  // Penetrating weapons also fall into this category but they are handled separately\n  const specialRuleAddPierceAgainstShield = ['Spread', 'Cauterize', 'Kinetic', 'Blast', 'Kill', 'Carpet']\n\n  const addsPierceAgainstEnergyShields = weaponSpecialRules.some((trait) => specialRuleAddPierceAgainstShield.includes(trait))\n\n  /*\n        The headshot special rule means that the target does not add their toughness modifier to their resistance.\n    */\n  const headshot = weaponSpecialRules.includes('Headshot')\n\n  /*\n        The kinetic special rule does a couple of things:\n        - Deals damage against the target without pierce if they have energy shields.\n        - If the target does not have energy shields, the attack adds 1D10 damage.\n    */\n  const kinetic = weaponSpecialRules.includes('Kinetic')\n\n  /*\n        The penetrating special rule does a couple of things:\n            - Deals pierce * 3 damage against energy shields or pierce * 5 if the weapon also has 'Blast' or 'Kill' special rules.\n            - Deals damage * 2 and pierce * 2 against cover points and physical shields.\n        This extra damage does not carry through to wounds.\n    */\n  const penetrating = weaponSpecialRules.includes('Penetrating')\n\n  const blast = weaponSpecialRules.includes('Blast')\n  const kill = weaponSpecialRules.includes('Kill')\n\n  return {\n    addsPierceAgainstEnergyShields,\n    headshot,\n    kinetic,\n    penetrating,\n    blast,\n    kill,\n  }\n}\n\nconst calculatePersonDamage = ({ damage, pierce, location, armour, weaponSpecialRules, coverLocations, coverPoints, energyShields }) => {\n  const mappedHitLocation = hitLocationMap[location]\n  const applyHeadshot = location === 'Head' && weaponSpecialRules.headshot\n  const isHitLocationInCover = coverLocations[mappedHitLocation]\n\n  let resistanceAtHitLocation = armour[mappedHitLocation]?.resistance\n\n  // Protection is the armour without toughness modifier applied\n  if (applyHeadshot) {\n    resistanceAtHitLocation = armour[mappedHitLocation].protection\n  }\n\n  // Blast weapons always hit the location with the lowest armour\n  // Locations in cover should not be considered for the damage\n  if (weaponSpecialRules.blast) {\n    const locationsNotInCover = Object.entries(armour).filter(([location]) => !coverLocations[location])\n    const lowestResistanceNotInCover = Math.min(...Object.values(locationsNotInCover).map(([_, armour]) => armour.resistance))\n\n    resistanceAtHitLocation = lowestResistanceNotInCover\n  }\n\n  // If location being hit is in cover, add the cover points to the overall resistance\n  if (isHitLocationInCover) {\n    resistanceAtHitLocation += coverPoints\n  }\n\n  // If the target has energy shields then the damage should be applied to the shields first\n  if (energyShields > 0) {\n    const { shieldDamage, armourDamage } = calculateEnergyShieldDamage({\n      damage,\n      pierce,\n      weaponSpecialRules,\n      energyShields,\n      isHitLocationInCover,\n      coverPoints,\n    })\n\n    let damageToArmour = armourDamage\n\n    // Kinetic weapons also deal damage to the armour through energy shields\n    if (weaponSpecialRules.kinetic) {\n      damageToArmour += damage\n    }\n\n    // If no damage got through to the target's armour, we don't need to do anything else\n    if (damageToArmour <= 0) {\n      return { shieldDamage, woundDamage: 0 }\n    }\n\n    // Any damage through to armour after damaging energy shields does not benefit from pierce so it isn't applied here\n    const damageThroughResistance = resistanceAtHitLocation > damageToArmour ? 0 : damageToArmour - resistanceAtHitLocation\n\n    return { shieldDamage, woundDamage: damageThroughResistance }\n  }\n\n  // If the pierce is greater than the damage resistance, it shouldn't add any damage. Instead it pierces through the target to whatever is behind and should be handled separately.\n  const effectiveResistance = pierce > resistanceAtHitLocation ? 0 : resistanceAtHitLocation - pierce\n\n  let damageBeforeResistance = damage\n\n  // Kinetic weapons deal additional damage against unshielded targets\n  if (weaponSpecialRules.kinetic) {\n    const extraKineticDamage = rollDice('1d10')\n    damageBeforeResistance += extraKineticDamage\n  }\n\n  const damageThroughResistance = damageBeforeResistance - effectiveResistance\n\n  // Make sure we don't apply negative damage which would give them wounds\n  if (damageThroughResistance <= 0) {\n    return { shieldDamage: 0, woundDamage: 0 }\n  }\n\n  return { shieldDamage: 0, woundDamage: damageThroughResistance }\n}\n\nconst calculateVehicleDamage = ({ damage, pierce, location, armour, weaponSpecialRules, coverLocations, coverPoints, energyShields }) => {\n  const isHitLocationInCover = coverLocations[location]\n\n  let armourAtHitLocation = armour[location].value\n\n  // If location being hit is in cover, add the cover points to the overall armour\n  if (isHitLocationInCover) {\n    armourAtHitLocation += coverPoints\n  }\n\n  // If the target has energy shields then the damage should be applied to the shields first\n  if (energyShields > 0) {\n    const { shieldDamage, armourDamage } = calculateEnergyShieldDamage({\n      damage,\n      pierce,\n      weaponSpecialRules,\n      energyShields,\n      isHitLocationInCover,\n      coverPoints,\n    })\n\n    let damageToArmour = armourDamage\n\n    // Kinetic weapons also deal damage to the armour through energy shields\n    if (weaponSpecialRules.kinetic) {\n      damageToArmour += damage\n    }\n\n    // If no damage got through to the target's armour, we don't need to do anything else\n    if (damageToArmour <= 0) {\n      return { shieldDamage, vehicleDamage: 0 }\n    }\n\n    // Any damage through to armour after damaging energy shields does not benefit from pierce so it isn't applied here\n    const damageThroughResistance = armourAtHitLocation > damageToArmour ? 0 : damageToArmour - armourAtHitLocation\n\n    return { shieldDamage, vehicleDamage: damageThroughResistance }\n  }\n\n  // If the pierce is greater than the armour, it shouldn't add any damage.\n  const effectiveResistance = pierce > armourAtHitLocation ? 0 : armourAtHitLocation - pierce\n\n  const damageThroughResistance = damage - effectiveResistance\n\n  // Make sure we don't apply negative damage which would give them wounds\n  if (damageThroughResistance <= 0) {\n    return { shieldDamage: 0, vehicleDamage: 0 }\n  }\n\n  return { shieldDamage: 0, vehicleDamage: damageThroughResistance }\n}\n\nconst calculateEnergyShieldDamage = ({ damage, pierce, weaponSpecialRules, energyShields, isHitLocationInCover, coverPoints }) => {\n  let damageToShields = damage\n  let pierceDamageToShields = 0\n\n  if (weaponSpecialRules.addsPierceAgainstEnergyShields) {\n    pierceDamageToShields += pierce\n  }\n\n  // Penetrating weapons do their pierce * 3 or 5 damage against energy shields\n  if (weaponSpecialRules.penetrating) {\n    if (weaponSpecialRules.blast || weaponSpecialRules.kill) {\n      pierceDamageToShields = pierce * 5\n    } else {\n      pierceDamageToShields = pierce * 3\n    }\n  }\n\n  damageToShields += pierceDamageToShields\n\n  // Cover still applies when damaging energy shields, so we need to reduce the damage by the coverPoints value if the target is in cover\n  const effectiveDamage = isHitLocationInCover ? damageToShields - coverPoints : damageToShields\n\n  // If the shield health is greater than the damage, then the energy shields absorb all the damage and we don't need to do anything else\n  if (energyShields > effectiveDamage) {\n    return { shieldDamage: effectiveDamage, armourDamage: 0 }\n  }\n\n  // If energy shields would be depleted, the remaining damage goes through to the target's armour\n  let damageThroughToArmour = effectiveDamage - energyShields\n\n  // If pierce was added to the damage against energy shields, it no longer applies when damage spills through to the target's armour\n  // Pierce is also applied first to the energy shields, before any of the base damage\n  if (weaponSpecialRules.addsPierceAgainstEnergyShields) {\n    const remainingPierce = pierceDamageToShields - energyShields\n\n    if (remainingPierce > 0) {\n      damageThroughToArmour -= remainingPierce\n    }\n  }\n\n  return { shieldDamage: energyShields, armourDamage: damageThroughToArmour }\n}\n\n/* Person Logic */\nconst generatePersonHitChatMessage = ({ actor, remainingShields, remainingWounds, totalDamage, shieldDamage, woundDamage, hasShields, hideDamageResult }) => {\n  const callsign = actor.name.match(/\"([^\"]+)\"/)\n  const actorName = callsign ? callsign[1] : actor.name\n\n  let chatMessage = `<b>${actorName}</b>`\n  chatMessage += '<br><br>'\n\n  if (totalDamage <= 0) {\n    chatMessage += 'No damage taken.'\n  } else {\n    if (remainingWounds <= 0) {\n      chatMessage += `<b>${actorName} is down!</b>`\n      chatMessage += '<br><br>'\n    }\n\n    if (hasShields) {\n      chatMessage += `<b>Shield damage:</b> ${shieldDamage}`\n\n      if (!hideDamageResult) {\n        chatMessage += '<br>'\n        chatMessage += `<b>Shields remaining:</b> ${remainingShields}`\n      }\n\n      chatMessage += '<br><br>'\n    }\n\n    chatMessage += `<b>Wound damage:</b> ${woundDamage}`\n\n    if (!hideDamageResult) {\n      chatMessage += '<br>'\n      chatMessage += `<b>Wounds remaining:</b> ${remainingWounds}`\n    }\n  }\n\n  return `\n        <div style=\"display: flex; flex-direction: row;\">\n            <img src=\"${actor.img}\" style=\"width: 50px; height: 50px; border-radius: 50%; margin-right: 10px;\">\n\n            <div>\n                ${chatMessage}\n            </div>\n        </div>\n    `\n}\n\nconst applyPersonHit = async ({ actor, remainingShields, remainingWounds, totalDamage, shieldDamage, woundDamage, hasShields, whisperResult, hideDamageResult }) => {\n  const chatMessage = generatePersonHitChatMessage({\n    actor,\n    remainingShields,\n    remainingWounds,\n    totalDamage,\n    shieldDamage,\n    woundDamage,\n    hasShields,\n    hideDamageResult,\n  })\n\n  await applyPersonDamage({ actor, remainingWounds, remainingShields })\n\n  ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: chatMessage,\n    // If the user wants the result to be private, only they will see the message\n    whisper: whisperResult ? [game.user._id] : null,\n  })\n}\n\nconst applyPersonDamage = async ({ actor, remainingWounds, remainingShields }) => {\n  await actor.update({\n    'system.wounds.value': remainingWounds,\n    'system.shields.value': remainingShields,\n  })\n}\n\nconst handlePersonHit = async ({\n  hitData,\n  appliedHits,\n  extraPierce,\n  damageMultiplier,\n  weaponSpecialRules,\n  coverLocations,\n  coverPoints,\n  actor,\n  whisperResult,\n  hideDamageResult,\n  calledShotLocation,\n}) => {\n  const hasShields = !!actor.system.shields.max\n  const currentShields = actor.system.shields.value\n  const currentWounds = actor.system.wounds.value\n  const armour = actor.system.armor\n\n  const hitResult = hitData.reduce(\n    (acc, curr) => {\n      const { hitNumber, damageInstances } = curr\n\n      if (!appliedHits[hitNumber]) {\n        // if hit wasn't checked we don't calculate damage, this could be because it was evaded for example\n        return acc\n      }\n\n      // Each hit can have multiple instances of damage, e.g burst fire so we need to loop over all of them\n      const damageResults = damageInstances.reduce(\n        (acc, curr) => {\n          const { damage, pierce, location } = curr\n\n          // Handle any extra pierce being applied from the form, e.g. from a charge\n          const totalPierce = pierce + extraPierce\n\n          // Handle any damage multipliers being applied from the form, e.g. from a grenade's kill radius\n          const totalDamage = damage * damageMultiplier\n\n          const { shieldDamage, woundDamage } = calculatePersonDamage({\n            damage: totalDamage,\n            pierce: totalPierce,\n            // Override with called shot location if one was specified, if not just use the location from the hit roll\n            location: calledShotLocation || location,\n            armour,\n            weaponSpecialRules,\n            coverLocations,\n            coverPoints,\n            energyShields: acc.remainingShields,\n          })\n\n          acc.totalDamage += shieldDamage\n          acc.totalDamage += woundDamage\n          acc.woundDamage += woundDamage\n          acc.shieldDamage += shieldDamage\n          acc.remainingShields -= shieldDamage\n          acc.remainingWounds -= woundDamage\n\n          return acc\n        },\n        { totalDamage: 0, shieldDamage: 0, woundDamage: 0, remainingWounds: acc.remainingWounds, remainingShields: acc.remainingShields }\n      )\n\n      acc.totalDamage += damageResults.totalDamage\n      acc.shieldDamage += damageResults.shieldDamage\n      acc.woundDamage += damageResults.woundDamage\n      acc.remainingWounds = damageResults.remainingWounds\n      acc.remainingShields = damageResults.remainingShields\n\n      return acc\n    },\n    { totalDamage: 0, shieldDamage: 0, woundDamage: 0, remainingWounds: currentWounds, remainingShields: currentShields }\n  )\n\n  const { totalDamage, shieldDamage, woundDamage, remainingWounds, remainingShields } = hitResult\n\n  await applyPersonHit({ actor, remainingShields, remainingWounds, totalDamage, shieldDamage, woundDamage, hasShields, whisperResult, hideDamageResult })\n}\n\n/* Vehicle Logic */\nconst generateVehicleHitChatMessage = ({ actor, remainingShields, currentBreakpoints, remainingBreakpoints, totalDamage, vehicleDamage, shieldDamage, hasShields, hideDamageResult }) => {\n  const callsign = actor.name.match(/\"([^\"]+)\"/)\n  const actorName = callsign ? callsign[1] : actor.name\n\n  const damagedBreakpoints = Object.entries(remainingBreakpoints).reduce((acc, [key, value]) => {\n    if (value.value < currentBreakpoints[key].value) {\n      acc[key] = {\n        damageTaken: currentBreakpoints[key].value - value.value,\n        remainingHealth: value.value,\n      }\n    }\n\n    return acc\n  }, {})\n\n  let chatMessage = `<b>${actorName}</b>`\n  chatMessage += '<br><br>'\n\n  // Vehicle took no damage\n  if (totalDamage <= 0) {\n    chatMessage = `No damage taken.`\n  } else {\n    if (hasShields) {\n      chatMessage += `<b>Shield damage:</b> ${shieldDamage}`\n\n      if (!hideDamageResult) {\n        chatMessage += '<br>'\n        chatMessage += `<b>Remaining shields:</b> ${remainingShields}`\n      }\n\n      chatMessage += '<br><br>'\n    }\n\n    Object.entries(damagedBreakpoints).forEach(([key, data]) => {\n      chatMessage += `<b>${reversedVehicleBreakpointMap[key]} damage:</b> ${data.damageTaken}`\n\n      if (!hideDamageResult) {\n        chatMessage += '<br>'\n        chatMessage += `<b>${reversedVehicleBreakpointMap[key]} integrity:</b> ${data.remainingHealth}`\n      }\n\n      chatMessage += '<br><br>'\n    })\n  }\n\n  return `\n        <div style=\"display: flex; flex-direction: row;\">\n            <img src=\"${actor.img}\" style=\"width: 50px; height: 50px; border-radius: 50%; margin-right: 10px;\">\n\n            <div>\n                ${chatMessage}\n            </div>\n        </div>\n    `\n}\n\nconst applyVehicleDamage = async ({ actor, remainingShields, remainingBreakpoints }) => {\n  Object.entries(remainingBreakpoints).map(async ([key, value]) => {\n    await actor.update({\n      [`system.breakpoints.${key}.value`]: value.value,\n    })\n  })\n\n  await actor.update({\n    'system.shields.value': remainingShields,\n  })\n}\n\nconst applyVehicleHit = async ({ actor, remainingShields, currentBreakpoints, remainingBreakpoints, totalDamage, vehicleDamage, shieldDamage, hasShields, whisperResult, hideDamageResult }) => {\n  const chatMessage = generateVehicleHitChatMessage({ actor, remainingShields, currentBreakpoints, remainingBreakpoints, totalDamage, vehicleDamage, shieldDamage, hasShields, hideDamageResult })\n\n  await applyVehicleDamage({ actor, remainingShields, remainingBreakpoints })\n\n  await ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: chatMessage,\n    // If the user wants the result to be private, only they will see the message\n    whisper: whisperResult ? [game.user._id] : null,\n  })\n}\n\nconst handleVehicleCrewHit = async ({\n  actor,\n  hitRoll,\n  pierce,\n  extraPierce,\n  damage,\n  damageMultiplier,\n  vehicleHitLocation,\n  weaponSpecialRules,\n  coverLocations,\n  coverPoints,\n  whisperResult,\n  hideDamageResult,\n}) => {\n  const crew = actor.system.crew\n  const isOpenTop = actor.system.special.openTop.has\n\n  const crewActorIds = [\n    ...crew.operators.map((operator) => operator.id).filter((id) => id !== null),\n    ...crew.gunners.map((gunner) => gunner.id).filter((id) => id !== null),\n    ...crew.complement.map((complement) => complement.id).filter((id) => id !== null),\n  ]\n\n  // Get actors for crew and determine if they get hit\n  // Finding the actors with game.actors here doesn't work as it only returns the base actor, it doesn't include armour or anything\n  const crewActors = crewActorIds.map((id) => canvas.tokens.placeables.find((token) => token.actor._id === id)?.actor).filter((actor) => actor)\n\n  if (crewActors.length) {\n    // 5% chance to hit a crew member if damage has penetrated the hull\n    const crewActorsHit = crewActors.filter(() => rollDice('d100') >= 96)\n\n    if (crewActorsHit.length) {\n      // Calculate hit location for crew member based on the hit roll\n      const crewHitLocation = calculateHitLocation(hitRoll)\n\n      // Refactor the loop to be async\n      for (let crewActor of crewActorsHit) {\n        const totalPierce = pierce + extraPierce\n        const totalDamage = damage * damageMultiplier\n        const crewMemberHasShields = !!crewActor.system.shields.max\n        const crewMemberCurrentWounds = crewActor.system.wounds.value\n        const crewMemberCurrentShields = crewActor.system.shields.value\n\n        let crewArmour = crewActor.system.armor\n        const vehicleArmourValue = actor.system.armor[vehicleHitLocation].value\n\n        // If vehicle isn't open top then the crew gets the benefits of the vehicle's armour\n        if (!isOpenTop) {\n          crewArmour = Object.fromEntries(\n            Object.entries(crewArmour).map(([key, stats]) => [\n              key,\n              {\n                protection: stats.protection + vehicleArmourValue,\n                resistance: stats.resistance + vehicleArmourValue,\n              },\n            ])\n          )\n        }\n\n        const { shieldDamage, woundDamage } = calculatePersonDamage({\n          damage: totalDamage,\n          pierce: totalPierce,\n          location: crewHitLocation,\n          armour: crewArmour,\n          weaponSpecialRules,\n          coverLocations,\n          coverPoints,\n          energyShields: crewMemberCurrentShields,\n        })\n\n        await applyPersonHit({\n          actor: crewActor,\n          remainingShields: crewMemberCurrentShields - shieldDamage,\n          remainingWounds: crewMemberCurrentWounds - woundDamage,\n          totalDamage: shieldDamage + woundDamage,\n          shieldDamage,\n          woundDamage,\n          hasShields: crewMemberHasShields,\n          whisperResult,\n          hideDamageResult,\n        })\n      }\n    }\n  }\n}\n\nconst handleVehicleHit = async ({\n  hitData,\n  appliedHits,\n  extraPierce,\n  damageMultiplier,\n  weaponSpecialRules,\n  coverLocations,\n  coverPoints,\n  actor,\n  whisperResult,\n  vehicleHitLocation,\n  hideDamageResult,\n  breakpointOverride,\n}) => {\n  const hasShields = !!actor.system.shields.max\n  const currentShields = actor.system.shields.value\n  const currentBreakpoints = actor.system.breakpoints\n  const armour = actor.system.armor\n\n  // Initialize accumulator values\n  let totalDamage = 0\n  let shieldDamage = 0\n  let vehicleDamage = 0\n  let remainingBreakpoints = structuredClone(currentBreakpoints)\n  let remainingShields = currentShields\n\n  for (let hit of hitData) {\n    const { hitNumber, hitRoll, damageInstances } = hit\n\n    // If hit wasn't applied we don't need to do anything for this hit\n    if (!appliedHits[hitNumber]) {\n      continue\n    }\n\n    // Initialize damage accumulator for the current hit\n    let damageResult = { totalDamage: 0, shieldDamage: 0, vehicleDamage: 0, remainingBreakpoints: { ...remainingBreakpoints }, remainingShields }\n\n    for (let damageInstance of damageInstances) {\n      const { damage, pierce, location } = damageInstance\n\n      let breakpointHitLocation = breakpointOverride || location\n\n      // TODO handle armour being halved when vehicle hull reaches 0\n      // TODO handle damage taken when hull is 0\n      // If targeting a breakpoint that is already destroyed, the damage is applied to the hull instead\n      if (!damageResult.remainingBreakpoints[vehicleBreakpointMap[breakpointHitLocation]] || damageResult.remainingBreakpoints[vehicleBreakpointMap[breakpointHitLocation]].value <= 0) {\n        breakpointHitLocation = 'Hull'\n      }\n\n      // Handle any extra pierce being applied from the form, e.g. from a charge\n      const totalPierce = pierce + extraPierce\n\n      // Handle any damage multipliers being applied from the form, e.g. from a grenade's kill radius\n      const totalDamage = damage * damageMultiplier\n\n      const { shieldDamage, vehicleDamage } = calculateVehicleDamage({\n        damage: totalDamage,\n        pierce: totalPierce,\n        location: vehicleHitLocation,\n        armour,\n        weaponSpecialRules,\n        coverLocations,\n        coverPoints,\n        energyShields: damageResult.remainingShields,\n      })\n\n      // If hitting hull and damage has penetrated the hull, there is a 5% chance to hit a crew member\n      if (breakpointHitLocation === 'Hull' && vehicleDamage >= 0) {\n        await handleVehicleCrewHit({\n          actor,\n          hitRoll,\n          pierce,\n          extraPierce,\n          damage,\n          damageMultiplier,\n          vehicleHitLocation,\n          weaponSpecialRules,\n          coverLocations,\n          coverPoints,\n          whisperResult,\n          hideDamageResult,\n        })\n      }\n\n      const mappedBreakpointHitLocation = vehicleBreakpointMap[breakpointHitLocation]\n\n      // Accumulate results into the damageResult\n      damageResult.totalDamage += shieldDamage\n      damageResult.totalDamage += vehicleDamage\n      damageResult.vehicleDamage += vehicleDamage\n      damageResult.shieldDamage += shieldDamage\n      damageResult.remainingShields -= shieldDamage\n      damageResult.remainingBreakpoints = {\n        ...damageResult.remainingBreakpoints,\n        [mappedBreakpointHitLocation]: {\n          ...damageResult.remainingBreakpoints[mappedBreakpointHitLocation],\n          value: damageResult.remainingBreakpoints[mappedBreakpointHitLocation].value - vehicleDamage,\n        },\n      }\n    }\n\n    // After processing all damage instances, add the results to the overall accumulator\n    totalDamage += damageResult.totalDamage\n    shieldDamage += damageResult.shieldDamage\n    vehicleDamage += damageResult.vehicleDamage\n    remainingShields = damageResult.remainingShields\n    remainingBreakpoints = Object.entries(damageResult.remainingBreakpoints).reduce(\n      (breakpoints, [key, value]) => ({\n        ...breakpoints,\n        [key]: {\n          ...breakpoints[key],\n          value: value.value,\n        },\n      }),\n      remainingBreakpoints\n    )\n  }\n\n  await applyVehicleHit({\n    actor,\n    remainingShields,\n    currentBreakpoints,\n    remainingBreakpoints,\n    totalDamage,\n    vehicleDamage,\n    shieldDamage,\n    hasShields,\n    whisperResult,\n    hideDamageResult,\n  })\n}\n\n// Html for the dialog\nconst dialogStyles = `\n<style>\n    .form {\n        margin-bottom: 5px;\n        display: flex;\n        flex-direction: column;\n        gap: 5px;\n    }\n    .form-section {\n        display: flex;\n        flex-wrap: nowrap;\n        align-items: center;\n        gap: 10px;\n    }\n    .cover-locations-container, .vehicle-hit-locations-container, .breakpoint-hit-locations-container, .called-shot-locations-container {\n        display: flex;\n        flex-wrap: wrap;\n        gap: 10px;\n    }\n    .checkbox-label, .location.radio.label {\n        display: flex;\n        align-items: center;\n        cursor: pointer;\n    }\n    .location-checkbox-label {\n        width: calc(33.33% - 10px);\n    }\n    .input-label {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        white-space: nowrap;\n    }\n    .vehicle-hit-locations-container input[type=\"radio\"], .called-shot-locations-container input[type=\"radio\"] {\n        transform: scale(1.4);\n        margin-right: 5px;\n        cursor: pointer;\n    }\n</style>\n`\n\nconst coverLocationsSection = `\n        <fieldset class=\"form-section cover-form-section\">\n            <legend>Locations in Cover</legend>\n            <div class=\"cover-locations-container\">\n                <!-- Dynamically generated checkboxes will render here -->\n            </div>\n        </fieldset>\n`\n\nconst whisperResultSection = `\n<fieldset class=\"form-section\">\n    <legend>Options</legend>\n    <label class=\"checkbox-label\">\n        <input type=\"checkbox\" name=\"whisperResult\" value=\"whisperResult\" />\n        Whisper Result\n    </label>\n\n    <label class=\"checkbox-label\">\n        <input type=\"checkbox\" name=\"hideDamageResult\" value=\"hideDamageResult\" />\n        Hide Damage Result\n    </label>\n</fieldset>\n`\n\nconst resistanceModifiersSection = `\n<fieldset class=\"form-section\">\n    <legend>Resistance Modifiers</legend>\n    <label class='input-label'>\n        Cover Points\n        <input type=\"number\" name=\"coverPoints\" class=\"cover-points-input\" value=\"0\" />\n    </label>\n\n    <label class='input-label'>\n        Extra Pierce\n        <input type=\"number\" name=\"extraPierce\" class=\"extra-pierce-input\" value=\"0\" />\n    </label>\n</fieldset>\n`\n\nconst damageModifiersSection = `\n<fieldset class=\"form-section\">\n    <legend>Damage Modifiers</legend>\n    <label class='input-label'>\n        Damage Multiplier\n        <input type=\"number\" name=\"damageMultiplier\" class=\"damage-multiplier-input\" value=\"1\" />\n    </label>\n</fieldset>\n`\n\nconst hitsSection = `\n<fieldset class=\"form-section\">\n    <legend>Hits</legend>\n    <div class=\"damage-instances-container\">\n        <!-- Dynamically generated checkboxes will render here -->\n    </div>\n</fieldset>\n`\n\nconst formSection = `\n<form class='form'>\n    ${whisperResultSection}\n    ${resistanceModifiersSection}\n    ${damageModifiersSection}\n    ${coverLocationsSection}\n    ${hitsSection}\n</form>\n`\n\nnew Dialog({\n  title: 'Damage Calculator',\n  content: `\n        ${dialogStyles}\n        ${formSection}\n    `,\n  buttons: {\n    confirm: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: 'Calculate',\n      callback: async (html) => {\n        const { actor, token } = getTarget()\n\n        if (!actor || !token) {\n          ui.notifications.error('No target found.')\n          return\n        }\n\n        // Parse all the form data inputs\n        // Options\n        const whisperResult = html.find(\"input[name='whisperResult']\").is(':checked')\n        const hideDamageResult = html.find(\"input[name='hideDamageResult']\").is(':checked')\n\n        // Resistance modifiers\n        const coverPoints = parseInt(html.find(\"input[name='coverPoints']\").val(), 10)\n        const extraPierce = parseInt(html.find(\"input[name='extraPierce']\").val(), 10)\n\n        // Damage modifiers\n        const damageMultiplier = parseInt(html.find(\"input[name='damageMultiplier']\").val(), 10)\n\n        // Called shot location\n        const calledShotLocation = html.find(\"input[name='calledShotLocation']:checked\").val()\n\n        // Cover Locations\n        const coverLocationInputs = html.find(\"input[name='coverLocation']\")\n\n        // Hits\n        const hits = html.find(\"input[name='hits']\")\n        const breakpointHitLocationInputs = html.find(\"input[name='breakpointHitLocation']\")\n\n        const coverLocations = coverLocationInputs.toArray().reduce((acc, curr) => {\n          const location = curr.value\n          acc[location] = curr.checked\n          return acc\n        }, {})\n\n        const appliedHits = hits.toArray().reduce((acc, curr) => {\n          const hit = curr.value\n          acc[hit] = curr.checked\n          return acc\n        }, {})\n\n        const breakpointHitLocations = breakpointHitLocationInputs.toArray().reduce((acc, curr) => {\n          if (curr.checked) {\n            acc.push(reversedVehicleBreakpointMap[curr.value])\n          }\n\n          return acc\n        }, [])\n\n        const lastAttackMessage = getLastAttackFromChat()\n\n        if (!lastAttackMessage) {\n          ui.notifications.error('No attack message found in chat')\n          return\n        }\n\n        // Extract data from the last attack\n        const hitData = extractDataForHits(lastAttackMessage.content)\n\n        const isAttackAgainstVehicle = hitData.every((hit) => hit.damageInstances.every((instance) => instance.location in vehicleBreakpointMap))\n\n        // Make sure the target is a vehicle if the attack is against a vehicle\n        // Crew of the vehicle being hit will be handled automatically\n        if (isAttackAgainstVehicle && actor.type !== 'Vehicle') {\n          ui.notifications.error('Vehicle hit detected but target is not a vehicle.')\n          return\n        }\n\n        const lastAttackHtml = parser.parseFromString(lastAttackMessage.content, 'text/html')\n\n        // Get weapon traits from weapon used in the attack\n        const weaponSpecialRules = getWeaponSpecialRules(lastAttackHtml)\n\n        const hasShields = !!actor.system.shields.max\n\n        // If target is a vehicle we have to handle this differently\n        if (actor.type === 'Vehicle') {\n          // Vehicle hit locations\n          const vehicleHitLocationInputs = html.find(\"input[name='vehicleHitLocation']\")\n          const vehicleHitLocation = vehicleHitLocationInputs.toArray().find((input) => input.checked)?.value || null\n\n          if (!vehicleHitLocation) {\n            ui.notifications.error('No vehicle hit location selected.')\n            return\n          }\n\n          for (const breakpoint of breakpointHitLocations) {\n            const { actor: updatedActor } = getTarget()\n\n            await handleVehicleHit({\n              hitData,\n              appliedHits,\n              extraPierce,\n              damageMultiplier,\n              armour: updatedActor.system.armor,\n              weaponSpecialRules,\n              coverLocations,\n              coverPoints,\n              currentBreakpoints: updatedActor.system.breakpoints,\n              currentShields: updatedActor.system.shields.value,\n              actor: updatedActor,\n              whisperResult,\n              hasShields,\n              vehicleHitLocation,\n              hideDamageResult,\n              breakpointOverride: breakpoint,\n            })\n          }\n        } else {\n          const { actor: updatedActor } = getTarget()\n\n          await handlePersonHit({\n            hitData,\n            appliedHits,\n            extraPierce,\n            damageMultiplier,\n            armour: updatedActor.system.armor,\n            weaponSpecialRules,\n            coverLocations,\n            coverPoints,\n            currentWounds: updatedActor.system.wounds.value,\n            currentShields: updatedActor.system.shields.value,\n            actor: updatedActor,\n            whisperResult,\n            hasShields,\n            hideDamageResult,\n            calledShotLocation,\n          })\n        }\n      },\n    },\n    cancel: {\n      label: 'Cancel',\n    },\n  },\n  // In some cases we need to dynamically inject some html into the dialog as it renders, this is because we need context of certain data points to know what to render\n  render: (html) => {\n    // Render cover options, this differs if the target is a vehicle or not\n    const { actor } = getTarget()\n\n    if (!actor) {\n      ui.notifications.error('No target found.')\n      return\n    }\n\n    const lastAttackMessage = getLastAttackFromChat()\n\n    if (!lastAttackMessage) {\n      ui.notifications.error('No attack message found in chat')\n      return\n    }\n\n    const hitData = extractDataForHits(lastAttackMessage.content)\n\n    // If target is a vehicle then we want to render some extra form elements\n    if (actor.type === 'Vehicle') {\n      const vehicleHitLocations = ['Front', 'Side', 'Back', 'Top', 'Bottom']\n      const locationFormOptions = vehicleHitLocations.map((location) => ({ name: location.toLowerCase(), label: location }))\n      const coverLocationsContainer = html.find('.cover-locations-container')\n\n      const lastAttackHtml = parser.parseFromString(lastAttackMessage.content, 'text/html')\n      const weaponSpecialRules = getWeaponSpecialRules(lastAttackHtml)\n\n      // Cover locations\n      locationFormOptions.forEach((location) => {\n        const label = $(`\n                    <label class=\"location-checkbox-label checkbox-label\">\n                        <input type=\"checkbox\" name=\"coverLocation\" value=\"${location.name}\" />\n                        ${location.label}\n                    </label>`)\n\n        coverLocationsContainer.append(label)\n      })\n\n      const vehicleHitLocationsSection = `\n                <fieldset class=\"form-section vehicle-hit-locations-form-section\">\n                    <legend>Vehicle hit Location</legend>\n                    <div class=\"vehicle-hit-locations-container\">\n                        <!-- Dynamically generated checkboxes will render here -->\n                    </div>\n                </fieldset>\n            `\n\n      // Dynamically add vehicle hit location before cover locations section\n      html.find('.form .cover-form-section').before(vehicleHitLocationsSection)\n\n      const vehicleHitLocationsContainer = html.find('.vehicle-hit-locations-container')\n\n      // Hit direction locations\n      locationFormOptions.forEach((location, index) => {\n        const defaultSelection = index === 0\n\n        const label = $(`\n                    <label class=\"location-radio-label radio-label\">\n                        <input type=\"radio\" name=\"vehicleHitLocation\" value=\"${location.name}\" ${defaultSelection ? 'checked' : ''} />\n                        ${location.label}\n                    </label>`)\n\n        vehicleHitLocationsContainer.append(label)\n      })\n\n      const hitLocations = hitData.map((hit) => hit.damageInstances[0].location).filter((location) => !!location)\n\n      // Breakpoint hit locations\n      const breakpointHitLocations = `\n                <fieldset class=\"form-section breakpoint-hit-locations-form-section\">\n                    <legend>Breakpoint hit locations</legend>\n                    <div class=\"breakpoint-hit-locations-container\">\n                        <!-- Dynamically generated checkboxes will render here -->\n                    </div>\n                </fieldset>\n            `\n\n      html.find('.form .cover-form-section').before(breakpointHitLocations)\n\n      const breakpointFormOptions = Object.entries(vehicleBreakpointMap).map(([key, value]) => ({ name: value, label: key }))\n\n      const breakpointHitLocationsContainer = html.find('.breakpoint-hit-locations-container')\n\n      breakpointFormOptions.forEach((location) => {\n        const label = $(`\n                    <label class=\"location-checkbox-label checkbox-label\">\n                        <input\n                            type=\"checkbox\"\n                            name=\"breakpointHitLocation\"\n                            value=\"${location.name}\"\n                            ${weaponSpecialRules.blast || hitLocations.includes(location.label) ? 'checked' : ''}\n                        />\n                        ${location.label}\n                    </label>`)\n\n        breakpointHitLocationsContainer.append(label)\n      })\n    } else {\n      const hitLocations = hitData.map((hit) => hit.damageInstances[0].location).filter((location) => !!location)\n\n      if (hitLocations.length) {\n        const calledShotLocationSection = `\n                    <fieldset class=\"form-section called-shot-locations-form-section\">\n                        <legend>Called shot location</legend>\n                        <div class=\"called-shot-locations-container\">\n                            <!-- Dynamically generated checkboxes will render here -->\n                        </div>\n                    </fieldset>\n                `\n\n        // Dynamically add person hit location before cover locations section\n        html.find('.form .cover-form-section').before(calledShotLocationSection)\n\n        const calledShotLocationContainer = html.find('.called-shot-locations-container')\n\n        const calledShotLocationFormOptions = Object.entries(hitLocationMap).map(([key, _]) => ({ name: key, label: key }))\n\n        // Person hit locations\n        calledShotLocationFormOptions.forEach((location) => {\n          const label = $(`\n                        <label class=\"location-radio-label radio-label\">\n                            <input type=\"radio\" name=\"calledShotLocation\" value=\"${location.name}\" />\n                            ${location.label}\n                        </label>`)\n\n          calledShotLocationContainer.append(label)\n        })\n      }\n\n      const locationFormOptions = Object.entries(hitLocationMap).map(([key, value]) => ({ name: value, label: key }))\n      const coverLocationsContainer = html.find('.cover-locations-container')\n\n      locationFormOptions.forEach((location) => {\n        const label = $(`\n                    <label class=\"location-checkbox-label checkbox-label\">\n                        <input type=\"checkbox\" name=\"coverLocation\" value=\"${location.name}\" />\n                        ${location.label}\n                    </label>`)\n\n        coverLocationsContainer.append(label)\n      })\n    }\n\n    // Render hits from the last attack chat message\n    const damageInstancesContainer = html.find('.damage-instances-container')\n\n    hitData.forEach((hit) => {\n      const { hitNumber, damageInstances } = hit\n\n      const damageText = damageInstances.map(({ damage }) => damage).join(', ')\n      // Pierce should be the same for all damage instances of a single hit, e.g using burst fire\n      const pierce = damageInstances[0].pierce\n      const hitLocation = damageInstances[0].location\n\n      const label = $(`\n                <label class=\"checkbox-label\">\n                    <input type=\"checkbox\" name=\"hits\" value=\"${hitNumber}\" checked />\n                    Hit ${hitNumber} || ${damageText} Damage | Pierce ${pierce} | ${hitLocation}\n                </label>`)\n\n      damageInstancesContainer.append(label)\n    })\n  },\n}).render(true)\n"
  },
  {
    "_id": "mythic-batch-damage-calculator",
    "name": "Ordnance Damage Calculator",
    "type": "script",
    "scope": "global",
    "img": "modules/mythic-addon/assets/airstrike.svg",
    "command": "const rollDice = (dice) => {\n  const roll = new Roll(dice).evaluate({ async: false })\n  return roll.total\n}\n\nconst calculateDamage = ({ actor, damage, pierce, damageMultiplier }) => {\n  const armour = actor.system.armor\n  const shields = actor.system.shields.value\n\n  const lowestArmour = Math.min(...Object.values(armour).map((part) => part.resistance))\n\n  let remainingDamage = damage * damageMultiplier\n\n  let shieldDamage = 0\n  let woundDamage = 0\n\n  if (shields > 0) {\n    if (shields >= remainingDamage) {\n      shieldDamage = remainingDamage\n      remainingDamage = 0\n    } else {\n      shieldDamage = shields\n      remainingDamage -= shields\n    }\n  }\n\n  if (remainingDamage > 0) {\n    remainingDamage += pierce\n    remainingDamage -= lowestArmour\n\n    if (remainingDamage > 0) {\n      woundDamage = remainingDamage\n    }\n  }\n\n  return { shieldDamage, woundDamage }\n}\n\nconst calculateBatchDamage = async ({ damageRoll, pierce, damageMultiplier }) => {\n  const selectedTokens = canvas.tokens.controlled\n\n  if (!selectedTokens.length) {\n    ui.notifications.error('No tokens selected.')\n    return\n  }\n\n  if (selectedTokens.some((token) => token.actor.type === 'Vehicle')) {\n    ui.notifications.error('Vehicles not supported.')\n    return\n  }\n\n  const damage = rollDice(damageRoll)\n\n  if (!damage) {\n    ui.notifications.error('Invalid damage roll.')\n    return\n  }\n\n  const tokensToUpdate = selectedTokens.map(async (token, index) => {\n    const { shieldDamage, woundDamage } = calculateDamage({ actor: token.actor, damage, pierce, damageMultiplier })\n\n    await token.actor.update({\n      'system.wounds.value': token.actor.system.wounds.value - woundDamage,\n      'system.shields.value': token.actor.system.shields.value - shieldDamage,\n    })\n\n    if (token.actor.system.wounds.value <= 0) {\n      return `[${index + 1}] ${token.actor.name} is dead.`\n    } else if (shieldDamage > 0) {\n      return `[${index + 1}] ${token.actor.name} took ${shieldDamage} shield damage and ${woundDamage} wound damage.`\n    } else {\n      return `[${index + 1}] ${token.actor.name} took ${woundDamage} wound damage.`\n    }\n  })\n\n  const messages = await Promise.all(tokensToUpdate)\n\n  const chatMessage = messages.join('<br>')\n\n  ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: chatMessage,\n  })\n}\n\nconst requiredSection = `\n<fieldset class=\"form-section\">\n    <legend>Required Inputs</legend>\n    <label class='input-label'>\n        Damage Roll\n        <input type=\"text\" name=\"damageRoll\" placeholder=\"e.g. 4d10 + 24\" />\n    </label>\n\n    <label class='input-label'>\n        Pierce\n        <input type=\"number\" name=\"pierce\" value=\"0\" />\n    </label>\n</fieldset>\n`\n\nconst damageModifiersSection = `\n<fieldset class=\"form-section\">\n    <legend>Damage Modifiers</legend>\n    <label class='input-label'>\n        Damage Multiplier\n        <input type=\"number\" name=\"damageMultiplier\" class=\"damage-multiplier-input\" value=\"1\" />\n    </label>\n</fieldset>\n`\n\nconst formSection = `\n<form class='form'>\n    ${requiredSection}\n    ${damageModifiersSection}\n</form>\n`\n\nconst dialogStyles = `\n<style>\n    .form {\n        margin-bottom: 5px;\n        display: flex;\n        flex-direction: column;\n        gap: 5px;\n    }\n    .form-section {\n        display: flex;\n        flex-wrap: nowrap;\n        align-items: center;\n        gap: 10px;\n    }\n    .input-label {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        white-space: nowrap;\n    }\n</style>\n`\n\nnew Dialog({\n  title: 'Ordnance Batch Damage Calculator',\n  content: `\n        ${dialogStyles}\n        ${formSection}\n    `,\n  buttons: {\n    confirm: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: 'Calculate',\n      callback: async (html) => {\n        const damageRoll = html.find(\"input[name='damageRoll']\").val()\n        const pierce = parseInt(html.find(\"input[name='pierce']\").val(), 10)\n        const damageMultiplier = parseInt(html.find(\"input[name='damageMultiplier']\").val(), 10)\n\n        await calculateBatchDamage({ damageRoll, pierce, damageMultiplier })\n      },\n    },\n    cancel: {\n      label: 'Cancel',\n    },\n  },\n}).render(true)\n"
  }
]